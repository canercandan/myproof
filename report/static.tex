\section{Instrumentation statique}

La problématique de cette partie était de dresser un profil statique du code considéré, c'est-à-dire obtenir une trace des accès mémoire à la compilation:

\begin{verbatim}
 fonction toto
 3 load
 2 * N load
 1 * N store
 2 load
 3 * M load
 3 * M store
 \end{verbatim}

 Ces accès mémoire se traduisent par les instructions load et store exécutées. Nous considérons qu'une instruction load est détectée lorsque le contenu d'un tableau est affectée à une variable, un store lorsqu'un tableau récupère la valeur d'une variable.\\

L'idée était donc de parcourir les blocs de base composant chaque fonction du code. La principale difficulté de cette phase de profiling consistait à détecter les éventuelles boucles présentes au sein d'une fonction, puis traiter les blocs de base, en évitant les redondances.\\

Cette opération a été effectuée en deux passes: le parsing des boucles (pass\_loop), puis celui des blocs de base courants (pass\_bb).\\

Dans les 2 passes, l'instrumentation se déroule de la façon suivante:

- La fonction principale de la passe parcourt tous les blocs de base à l'aide de la structure "FOR\_EACH\_BB". Puis, elle utilise un itérateur pour analyser les "statements", c'est-à-dire les lignes du bloc de base. Ceci est fait grâce à la fonction read\_stmt().
La fonction read\_stmt() qui est appelée permet de savoir si le statement correspond à un appel de fonction, un retour, une condition, ou plus simplement une affectation (GIMPLE\_ASSIGN). C'est ce dernier cas qui nous intéresse.\\
- Ensuite, nous avons besoin de savoir de quel côté de l'égalité nous sommes. read\_stmt() nous donne également la position de l'opérande (à droite ou à gauche de l'égalité). La fonction read\_operand(), quant à elle, détermine le type rencontré (en l'occurence, celui qui nous intéresse est INDIRECT\_REF).\\
- Lorsque ce cas est rencontré, on incrémente le compteur de loads si l'opérande est droite de l'égalité, et le compteur de stores si l'opérande se trouve à gauche.\\
\begin{verbatim}
	case INDIRECT_REF:
	    /* pointer & dereferencing */
	    if ( store == true ) { basicblock->nstore++; }
	    else { basicblock->nload++; }
	    break;
\end{verbatim}

La première passe (pass\_loop) détecte les éventuelles boucles présentes la fonction instrumentée, en la parcourant. Elle stocke dans une structure les blocs de base contenus dans lesdites boucles.\\
La détection des boucles est possible grâce du code suivant, au sein de la fonction pass\_loop():
\begin{verbatim} 
 if ( cfun->x_current_loops != NULL )
	{
	    read_loop( cfun->x_current_loops->tree_root, function );
	}
\end{verbatim}

La fonction read\_loop() permet de connaître les bornes des boucles rencontrées dans la fonction, et ainsi de multiplier le nombre des opérations éventuelles load et store par le nombre d'itérations de la boucle. Les blocs de base contenant ces boucles sont écartées du traitement classique des blocs, afin d'éviter des redondances.

La seconde passe (passe\_bb.c), quand à elle, reparcourt les blocs de base de la fonction, et vérifie pour chaque bloc considéré s'il a déjà été traité dans la passe précédente. Dans ce cas, elle passe au bloc de base suivant. Dans le cas contraire, elle analyse chaque statement du bloc.\\ 


