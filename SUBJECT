Cher tous,


vous connaissez déjà les modalités d'évaluation du cours de compilations. Celles ci reposent essentiellement sur votre travail dans un projet.

Voici donc le sujet du projet. N'hésitez pas a nous contacter pour toutes questions.

Bien cordialement,

  L'équipe Compilation


Remarques générales :
---------------------

  1) Ce qui est pris en compte :
       A) La lisibilité du code
       B) Ce qui a été fait : rien ne marche/une seule partie
  fonctionne/tout fonctionne comme demander/vous avez refait gprof
  entièrement en mieux en poussant le sujet au maximum
       C) La gestion des cas tordus potentiels
       D) La lisibilité du rapport et sa rédaction
       E) La présentation de votre code, de sa démo (donc de son  exécution), de ce que vous savez sur votre code (pouvez vous le  modifier  ou expliquer comment on pourrait l'étendre ?)
       F) La réponse aux questions de cours

  2) Si quelque chose n'est pas clair dans ce sujet ou cet email,  demandez-nous. Comme tout projet, la question n'est pas de voir que  vous  pouvez faire cela sans aide ou en trichant mais de vous menez à bon  port. Du coup, si vous êtes bloqués, il suffit de poser une question  et,  dans la mesure du possible, nous vous aiderons à trouver une solution.

  3) Nous vous fournirons des exemples de code que vous pouvez tester au  fur et à mesure du projet


  ----------------
  Sujet du projet:
  ----------------

  Le but de ce projet est la réalisation d'un outil ressemblant à l'outil  gprof.

  Nous allons ajouter des pragma dans le code pour sélectionner les  fonctions à profiler. Ces pragmas ne sont qu'utilisés si une certaine  option est passé au programme. Par exemple :

  #pragma instrumente foo
  void foo (int a)
  {
     ...
  }

  ...

  Avec :

  gcc test.c

  Ne fera rien, par contre :

  gcc -finstrumente test.c

  fera l'instrumentation de la fonction foo seulement.


  Partie 0: Gestion des pragmas et de l'option

  A) On accepte deux styles de définitions :

  #pragma instrumente foo
  #pragma instrumente (fct1, fct2)

  B) On accepte plusieurs pragmas dans un même fichier

  Ps: Si vous faites cela avec un plugin, automatiquement vous avez  l'option -finstrumente via l'utilisation de -fplugin=votre plugin.

  --------------------------------------------------------------------

  Partie 1: Génération statique d'un fichier de description des  fonctions:

  Il s'agit pour chaque fonction ou fragment de code ciblés par un pragma  de compter le nombre d'instruction de type load ou store. A la fin de  l'analyse ces informations sont stockées dans un fichier fixé en dur  dans votre code (par exemple: instrumentation.txt).

  Deux extensions optionnelles pour cette partie :

  1) Avoir une option pour définir le fichier de sortie à la compilation

  2) Il serait souhaitable de capturer dans le fichier résultats les
  bornes des boucles, ainsi on souhaite obtenir une équation statique
  décrivant le comportement mémoire de la fonction :

  Pour une fonction :

  int toto (int *tab)
  {
       int sum = tab[0] + tab[1] + tab[2];
       int i;

       for (i=0; i<    N; i++)
       {
          sum += tab[i] + 3 * tab[i+1];
          tab[i+1] = sum;
       }

       sum += tab[0] + tab[1];

       for (i=0; i<    M; i++)
       {
          sum += tab[i] + 3 * tab[i+1] + 4 * tab[i-1];
          tab[i+1] = sum;
          tab[i+2] = 2*sum;
          tab[i+3] = 3*sum;
       }
  }

  On aurait en sortie :

  fonction toto
  3 load
  2 * N load
  1 * N store
  2 load
  3 * M load
  3 * M store

  --------------------------------------------------------------------

  Partie 2: Réalisation d'une passe GCC pour l'instrumentation dynamique  de code.

  On aimerait instrumenter le code pour avoir les informations pendant  l'exécution du programme. Ainsi, on utilisera une librairie dynamique  qui sera chargée à l'exécution. Le compilateur ajoutera des appels vers  cette bibliothèque lors de la compilation.

  Une solution possible est d'avoir dans la bibliothèque runtime:
     - entrée et sortie d'une fonction
     - capture du nom et de l'identifiant d'une fonction
     - mise à jour des structures de données comptabilisant le temps  d'exécution ou les événements.

  Les résultats attendus de cette phase de 'profilage' est une trace  d'exécution.
  Appel 1 à la fonction toto entrée cycle WW sortie cycle XX
  [...]
  Appel 153 à la fonction tutu entrée cycle YY sortie cycle WW

  Pour cela, il va falloir utiliser une fonction temps comme rdtsc ou  gettimeofday (recherche google à souhait).

  --------------------------------------------------------------------

  Partie 3: Gestion des fichiers de sortie

  Nous avons donc, grâce aux parties 1 et 2 deux fichiers de sortie. Le  premier est généré pendant l'exécution et donne des informations sur le  code et le deuxième est généré pendant l'exécution. La question de  cette  troisième partie est de voir si nous pouvons corréler les deux.

  En utilisant, les outils LEX et YACC on écrira un parseur des fichiers  de trace obtenu lors de la partir 2 pour :

      - Construire un profilage exclusif et non plus plus inclusif comme  celui du fichier de trace.
      - Générer une courbe gnuplot illustrant la variabilité des  performance pour une meme fonction que cela soit en mode inclusif ou  exclusif.
		- Le temps inclusif d'une fonction est le temps de son code + le  temps d'exécution des fonctions qu'elle appelle
		- Le temps exclusif est le temps de la fonction seule, sans le  temps des appels de fonction qu'elle contient
   - Agréger les temps d'exécution des différentes instances d'une même  fonction.

Enfin, ce parseur sera étendu pour également prendre en entrée le  fichier d'annotation pour l'analyse statique et pour qu'il propose une  corrélation entre le temps d'exécution et le nombre d'instruction de  load et de store ainsi que les bornes de boucles.

  ----------------------------------------------------------------------

  Partie 4: Et le multi-thread dans tout cela ?

  Analysez votre code et déterminez s'il existe des endroits qui auront  des soucis dans le cas d'une exécution multi-threadée.

  S'il y en a, proposez des pistes pour une instrumentation multi-thread.

--
Jean-Thomas Acquaviva
  Group Leader Performance Evaluation Tools
Exascale Computing Research
45, Av. des Etats-Unis
78000 Versailles cedex
Tel: (+33) 139 254 078
www.exascale-computing.eu
